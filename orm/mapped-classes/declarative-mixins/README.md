## Composing Mapped Hierarchies with Mixins

A common need when _mapping classes using the Declarative style_ is to __share some functionality__, such as a `set of common columns`, `some common table options`, or `other mapped properties`, __across many classes__. The __standard Python idioms__ for this is to have the __classes inherit from a superclass__ which _includes these common features_.

When _using declarative mappings_, this idiom is __allowed via the usage of mixin classes__, as well as __via augmenting the declarative base__ produced by either the `registry.generate_base()` method or `declarative_base()` functions.

When using _mixins_ or _abstract base classes_ with `Declarative`, a _decorator_ known as `declared_attr()` is __frequently used__. This _decorator_ allows the __creation of class methods__ that _produce a parameter or ORM construct_ that will be part of a _declarative mapping_. _Generating constructs using a callable_ allows for `Declarative` to get a _new copy of a particular kind of object each time it calls_ upon the `mixin` or `abstract base` on behalf of a __new class that's being mapped__.

Where above, the class `UserModel` will contain an `"id"` column as the `primary key`, a `__tablename__` attribute that __derives from the name of the class itself__, as well as `__table_args__` and `__mapper_args__` defined by the `CustomMixin` _mixin class_. The `declared_attr()` _decorator_ applied to a _classmethod_ called `def __tablename__(cls):` has the effect of _turning the method into a classmethod_ while also indicating to `Declarative` that _this attribute_ is __significant within the mapping__.


> ##### Tip
> 
> The use of the `declarative_mixin()` _class decorator_ __marks a particular class as providing the service of providing SQLAlchemy declarative assignments__ as a mixin for other classes. This decorator is _currently only necessary to provide a hint to the Mypy plugin_ that this class should be handled as part of __declarative mappings__.

There's __no fixed convention__ over whether __`CustomMixin` precedes `Base` or not__. _Normal Python method resolution rules_ __apply__, and the above example would work just as well with:

```
class UserModel(Base, CustomMixin):
    age = Column(Integer)
```

This works because `Base` here __doesn't define any of the variables that `CustomMixin` defines__, i.e. `__tablename__`, `__table_args__`, `id`, etc. __If the `Base` did define an attribute of the same name__, the _class placed first_ in the _inherits list_ would __determine which attribute is used__ on the _newly defined class_.


#### Augmenting the Base

In addition to using a _pure mixin_, most of the techniques in this section _can also be applied_ to the `base class` itself, for _patterns_ that should apply to all classes __derived from a particular base__. This is achieved using the _cls argument_ of the `declarative_base()` function.

Where above, `MyModel` and _all other classes_ that __derive from `Base`__ will have a _table name_ __derived from the class name__, an `id` _primary key column_, as well as the `"InnoDB"` _engine for MySQL_.


#### Mixing in Columns

The _most basic way_ to __specify a column on a mixin__ is by _simple declaration_. Where above, _all declarative classes_ that include `TimestampMixin` will also have a column `created_at` that __applies a timestamp to all row insertions__.

Those familiar with the `SQLAlchemy expression language` know that the __object identity of clause elements defines their role in a schema__. Two `Table` objects _a and b may both have a column_ called `id`, but the way these are __differentiated__ is that `a.c.id` and `b.c.id` are _two distinct Python objects_, __referencing__ their _parent tables a and b_ respectively.

In the case of the _mixin column_, it seems that _only one_ `Column` object is __explicitly created__, yet the _ultimate_ `created_at` column above __must exist__ as a _distinct Python object for each separate destination class_. To accomplish this, the _declarative extension_ __creates a copy of each `Column` object__ encountered on a class that is detected as a _mixin_.

This _copy mechanism_ is __limited to simple columns__ that have __no foreign keys__, as a `ForeignKey` itself _contains references to columns_ which __can't be properly recreated__ at this level. For _columns that have foreign keys_, as well as for the _variety of mapper-level constructs_ that __require destination-explicit context__, the `declared_attr` decorator is provided so that _patterns common to many classes_ __can be defined as `callables`__.

Where above, the `address_id` _class-level callable_ is __executed at the point__ at which the `User` class is __constructed__, and the _declarative extension_ __can use the resulting `Column` object__ as returned by the method __without the need to copy it__.

`Columns` _generated by_ `declared_attr` can also be _referenced by_ `__mapper_args__` to a __limited degree__, currently by `polymorphic_on` and `version_id_col`; the _declarative extension_ will __resolve__ them at _class construction time_.


#### Mixing in Relationships

_Relationships_ created by `relationship()` are provided with _declarative mixin classes_ __exclusively__ using the `declared_attr` approach, __eliminating any ambiguity__ which could arise when _copying a relationship_ and its possibly _column-bound contents_. Below is an example which __combines a foreign key column and a relationship__ so that _two classes_ `Foo` and `Bar` can both be __configured to reference a common target class via many-to-one__.


##### Using Advanced Relationship Arguments (e.g. primaryjoin, etc.)

`relationship()` definitions which require *explicit primaryjoin, order_by etc. expressions* should in _all but the most simplistic cases_ use __late bound forms__ for these arguments, meaning, using either the __string form or a function/lambda__. The reason for this is that the related `Column` objects which are to be __configured using `@declared_attr`__ are _not available to another_ `@declared_attr` attribute; while the _methods will work and return_ __new `Column` objects__, those are __not__ the `Column` objects that _Declarative_ will be using as it _calls the methods on its own_, thus using __different__ `Column` objects.

The _canonical_ example is the `primaryjoin` condition that __depends upon another mixed-in column__.

```
@declarative_mixin
class ParamRefTargetMixin:
    @declared_attr
    def target_id(cls):
        return Column("target_id", ForeignKey("target.id"))
    
    @declared_attr
    def target(cls):
        return relationship(Target, primaryjoin=Target.id == cls.target_id) # this is *incorrect*
```

_Mapping_ a class using the above _mixin_, we __will get an error__ like:

```
sqlalchemy.exc.InvalidRequestError: this ForeignKey's parent column is not
yet associated with a Table.
```

This is because the *target_id* `Column` we've called upon in our `target()` method is __not the same `Column`__ that _declarative_ is __actually going to map to our table__.

The condition above is _resolved_ using a `lambda`:

```
@declarative_mixin
class ParamRefTargetMixin:
    @declared_attr
    def target_id(cls):
        return Column("target_id", ForeignKey("target.id"))
    
    @declared_attr
    def target(cls):
        return relationship(Target, primaryjoin=lambda: Target.id == cls.target_id)
```

or alternatively, the `string form` (which _ultimately generates_ a `lambda`):

```
@declarative_mixin
class ParamRefTargetMixin:
    @declared_attr
    def target_id(cls):
        return Column("target_id", ForeignKey("target.id"))
    
    @declared_attr
    def target(cls):
        return relationship(Target, primaryjoin=f"Target.id == {cls.__name__}.target_id")
```


#### Mixing in deferred(), column_property(), and other MapperProperty classes

Like `relationship()`, __all `MapperProperty` subclasses__ such as `deferred()`, `column_property()`, etc. ultimately _involve references to columns_, and therefore, when used with _declarative mixins_, have the `declared_attr` requirement so that __no reliance on copying is needed__.

The `column_property()` or _other construct_ may __refer to other columns from the mixin__. These are __copied ahead of time__ before the `declared_attr` is invoked.


#### Controlling table inheritance with mixins

The `__tablename__` attribute may be used to _provide a function that will determine the name of the table_ used for each class in an __inheritance hierarchy__, as well as whether a class has its _own distinct table_.

This is achieved using the `declared_attr` indicator __in conjunction with a method__ named `__tablename__()`. _Declarative_ will __always invoke__ `declared_attr` for the special names `__tablename__`, `__mapper_args__` and `__table_args__` function _for each mapped class in the hierarchy_, __except if overridden in a subclass__. The function therefore needs to _expect to receive_ __each class individually__ and to _provide_ the __correct answer for each__.

For example, to _create a mixin_ that gives every class a __simple table name based on class name__.

Alternatively, we can modify our `__tablename__` function to return `None` for _subclasses_, using `has_inherited_table()`. This has the _effect of those subclasses_ __being mapped with single table inheritance against the parent__.


#### Mixing in Columns in Inheritance Scenarios

In contrast to how `__tablename__` and _other special names_ are handled when used with `declared_attr`, when we _mix in columns and properties_ (e.g. `relationships`, `column properties`, etc.), the __function is invoked for the base class only in the hierarchy__. Below, __only__ the `Person` class will _receive a column called id_; the __mapping will fail__ on `Engineer`, which is _not given a primary key_.

```
@declarative_mixin
class HasId:
    @declared_attr
    def id(cls):
        return Column("id", Integer, primary_key=True)


class Person(HasId, Base):
    __tablename__ = "person"
    discriminator = Column("type", String(50))
    __mapper_args__ = {"polymorphic_on": discriminator}


class Engineer(Person):
    __tablename__ = "engineer"
    primary_language = Column(String(50))
    __mapper_args__ = {"polymorphic_identity": "engineer"}
```

> ##### Warning
> 
> The `declared_attr.cascading` feature __currently does not allow for a subclass to override__ the attribute _with a different function or value_. This is a _current limitation_ in the mechanics of how `@declared_attr` is resolved, and a _warning is emitted_ if this condition is detected. This _limitation_ __does not exist for the special attribute__ names such as `__tablename__`, which __resolve in a different way internally__ than that of `declared_attr.cascading`.


#### Combining Table/Mapper Arguments from Multiple Mixins

In the case of `__table_args__` or `__mapper_args__` specified with _declarative mixins_, you may want to _combine some parameters from several mixins_ with those you wish to define on the class itself. The `declared_attr` decorator can be used here to __create user-defined collation routines that pull from multiple collections__.


#### Creating Indexes with Mixins

To define a _named, potentially multicolumn_ `Index` that __applies to all tables derived from a mixin__, use the `"inline"` form of `Index` and establish it as _part of_ `__table_args__`.

```
@declarative_mixin
class IndexMixin:
    a = Column(Integer)
    b = Column(Integer)
    
    @declared_attr
    def __table_args__(cls):
        return (Index(f"test_idx_{cls.__tablename__}", "a", "b"), )


class MyModel(IndexMixin, Base):
    __tablename__ = "atable"
    
    c = Column(Integer, primary_key=True)
```
