## Basic Relationship Patterns

A quick walkthrough of the basic relational patterns. The imports used for each of the following sections is as follows:

```
from sqlalchemy import Column, ForeignKey, Integer, Table
from sqlalchemy.orm import declarative_base, relationship

Base = declarative_base()
```


#### One To Many

A _one to many relationship_ places a `foreign key` on the _child table_ referencing the _parent_. `relationship()` is then __specified on the parent__, as referencing a _collection of items_ represented by the child.

To establish a __bidirectional relationship__ in _one-to-many_, where the `"reverse"` side is a _many to one_, specify an __additional `relationship()`__ and connect the two using the `relationship.back_populates` parameter.

_Alternatively_, the `relationship.backref` option may be __used on a single `relationship()`__ instead of using `relationship.back_populates`.


##### Configuring Delete Behavior for One to Many

It is often the case that _all Child objects_ should be __deleted__ when their _owning Parent is deleted_. To _configure_ this behavior, the `delete cascade option` described at _delete_ is used. An additional option is that a _Child_ object __can itself be deleted__ when it is _deassociated from its parent_. This behavior is described at `delete-orphan`.


#### Many To One

_Many to one_ places a `foreign key` in the __parent table referencing the child__. `relationship()` is __declared on the parent__, where a _new scalar-holding attribute_ will be created.

_Bidirectional behavior_ is achieved by adding a __second__ `relationship()` and applying the `relationship.back_populates` parameter in __both directions__.

_Alternatively_, the `relationship.backref` parameter may be __applied to a single `relationship()`__, such as `Parent.child`.


#### One To One

_One To One_ is essentially a `bidirectional relationship` with a __scalar attribute on both sides__. Within the ORM, _"one-to-one"_ is considered as a convention where the ORM expects that __only one related row will exist for any parent row__.

The _"one-to-one"_ convention is achieved by _applying a value_ of `False` to the `relationship.uselist` parameter of the `relationship()` construct, or in some cases the `backref()` construct, applying it on the _"one-to-many"_ or _"collection"_ side of a relationship.

In the example below we present a _bidirectional relationship_ that includes both `one-to-many (Parent.children)` and a `many-to-one (Child.parent)` relationships.

Above, `Parent.children` is the _"one-to-many"_ side __referring to a collection__, and `Child.parent` is the _"many-to-one"_ side __referring to a single object__. To convert this to _"one-to-one"_, the _"one-to-many"_ or _"collection"_ side is __converted into a scalar relationship__ using the `uselist=False` flag, renaming `Parent.children` to `Parent.child` for clarity.

Above, when we load a _Parent_ object, the _Parent.child_ attribute will __refer to a single Child object rather than a collection__. If we _replace_ the value of _Parent.child_ with a _new Child object_, the ORM's unit of work process will replace the previous Child row with the new one, setting the previous *child.parent_id* column to `NULL` __by default unless there are specific `cascade behaviors` set up__.

> ##### Note
>
> As mentioned previously, the ORM considers the _"one-to-one"_ pattern as a convention, where it _makes the assumption_ that when it loads the _Parent.child_ attribute on a _Parent_ object, it will __get only one row back__. If _more than one row_ is returned, the ORM will __emit a warning__.
>
> However, the _Child.parent_ side of the above relationship remains as a _"many-to-one"_ relationship and is __unchanged__, and there is __no intrinsic system__ within the ORM itself that _prevents more than one Child object to be created against the same Parent during persistence_. Instead, techniques such as `unique constraints` may be used in the actual database schema to _enforce_ this arrangement, where a _unique constraint_ on the *Child.parent_id* column would __ensure__ that _only one Child row may refer to a particular Parent row_ at a time.

In the case where the `relationship.backref` parameter is used to define the _"one-to-many"_ side, this can be converted to the _"one-to-one"_ convention using the `backref()` function which allows the relationship generated by the `relationship.backref` parameter to __receive custom parameters__, in this case the _uselist_ parameter.


#### Many To Many

_Many to Many_ adds an __association table between two classes__. The _association table_ is indicated by the `relationship.secondary` argument to `relationship()`. Usually, the _Table_ uses the _MetaData_ object _associated with the declarative base class_, so that the `ForeignKey` directives can __locate the remote tables with which to link__.

> ##### Tip
>
> The _"association table"_ above has `foreign key constraints` established that refer to the two entity tables on either side of the relationship. The _data type_ of each of *association.left_id* and *association.right_id* is __normally inferred from that of the referenced table and may be omitted__. It is also __recommended__, though _not in any way required_ by SQLAlchemy, that the _columns which refer to the two entity tables_ are established within either a _unique constraint_ or more commonly as the _primary key constraint_; this ensures that __duplicate rows won't be persisted__ within the table regardless of issues on the application side.

```
association_table = Table(
    "association_table",
    Base.metadata,
    Column("left_id", ForeignKey("left_table.id"), primary_key=True),
    Column("right_id", ForeignKey("right_table.id"), primary_key=True),
)
```

For a `bidirectional relationship`, _both sides_ of the relationship __contain a collection__. Specify using `relationship.back_populates`, and for each `relationship()` specify the _common association table_.

When using the `relationship.backref` parameter instead of `relationship.back_populates`, the _backref_ will __automatically use the same__ `relationship.secondary` argument for the _reverse relationship_.

The `relationship.secondary` argument of `relationship()` __also accepts a callable that returns the ultimate argument__, which is __evaluated only when mappers are first used__. Using this, we can define the *association_table* at a __later point__, as long as it's available to the callable _after all module initialization is complete_.

```
class Parent(Base):
    __tablename__ = "left_table"
    id = Column(Integer, primary_key=True)
    children = relationship(
        "Child",
        secondary=lambda: association_table,
        backref="parents",
    )
```

With the _declarative extension_ in use, the _traditional "string name of the table"_ is __accepted__ as well, matching the name of the table as stored in `Base.metadata.tables`.

```
class Parent(Base):
    __tablename__ = "left_table"
    id = Column(Integer, primary_key=True)
    children = relationship("Child", secondary="association_table", backref="parents")
```

> ##### Warning
>
> When passed as a _Python-evaluable string_, the `relationship.secondary` argument is interpreted using Python's `eval()` function. __DO NOT PASS UNTRUSTED INPUT TO THIS STRING__.


##### Deleting Rows from the Many to Many Table

A _behavior_ which is __unique__ to the `relationship.secondary` argument to `relationship()` is that the _Table_ which is specified here is __automatically__ subject to _INSERT_ and _DELETE_ statements, as objects are _added or removed from the collection_. There is __no need to delete from this table manually__. The act of removing a record from the collection will have the effect of the row being deleted on flush.

```
# row will be deleted from the "secondary" table automatically
myparent.children.remove(somechild)
```

A question which often arises is how the _row in the "secondary" table_ can be __deleted__ when the _child_ object is __handed directly__ to `Session.delete()`.

```
session.delete(somechild)
```

There are several possibilities here:

* If there is a `relationship()` from Parent to Child, but there is not a _reverse-relationship_ that links a particular Child to each Parent, __SQLAlchemy will not have any awareness__ that when _deleting this particular Child object_, it needs to maintain the `"secondary"` table that _links it to the Parent_. __No delete of the "secondary" table will occur__.

* If there is a _relationship_ that links a particular Child to each Parent, suppose it's called `Child.parents`, SQLAlchemy _by default will load_ in the `Child.parents` collection to _locate all Parent objects_, and __remove each row from the "secondary" table which establishes this link__. Note that this _relationship_ __does not need__ to be `bidirectional`; SQLAlchemy is __strictly__ looking at every `relationship()` associated with the _Child object being deleted_.

* A _higher performing option_ here is to use `ON DELETE CASCADE` directives with the _foreign keys used by the database_. Assuming the database supports this feature, the database itself can be made to __automatically delete rows__ in the `"secondary"` table as referencing rows in `"child"` are deleted. SQLAlchemy can be __instructed to forego actively loading__ in the `Child.parents` collection in this case using the `relationship.passive_deletes` directive on `relationship()`.

Note again, these _behaviors_ are __only relevant__ to the `relationship.secondary` option used with `relationship()`. If dealing with _association tables_ that are __mapped explicitly__ and are __not present__ in the `relationship.secondary` option of a relevant `relationship()`, _cascade rules_ can be _used instead_ to __automatically delete entities__ in reaction to a related entity being deleted.


#### Association Object

The _association object pattern_ is a _variant on many-to-many_: it's used when your _association table_ __contains additional columns beyond those which are foreign keys__ to the left and right tables. Instead of using the `relationship.secondary` argument, you _map a new class directly_ to the association table. The _left side_ of the relationship references the _association object via one-to-many_, and the _association class references the right side via many-to-one_.

As always, the _bidirectional_ version makes use of `relationship.back_populates` or `relationship.backref`.

Working with the _association pattern_ in its _direct form_ __requires__ that __child objects are associated with an association instance before being appended to the parent__; similarly, _access from parent to child goes through the association object_:

```
# create parent, append a child via association
p = ParentModel()
a = AssociationModel(extra_data="some data")
a.child = ChildModel()
p.children.append(a)

# iterate through child objects via association, including association attributes
for assoc in p.children:
    print(assoc.extra_data)
    print(assoc.child)
```

To enhance the _association object pattern_ such that __direct access__ to the _Association_ object is __optional__, SQLAlchemy provides the __Association Proxy extension__. This extension allows the _configuration of attributes_ which will __access two "hops" with a single access__, one "hop" to the _associated object_, and a second to a _target attribute_.


#### Late-Evaluation of Relationship Arguments

Many of the examples in the preceding sections illustrate mappings where the various `relationship()` constructs __refer to their target classes using a string name__, rather than the class itself.

```
class Parent(Base):
    # ...
    children = relationship("Child", back_populates="parent")


class Child(Base):
    # ...
    parent = relationship("Parent", back_populates="children")
```

These _string names_ are __resolved into classes__ in the `mapper resolution stage`, which is an _internal process_ that occurs typically __after all mappings have been defined__ and is __normally triggered__ by the _first usage of the mappings_ themselves. The _registry_ object is the `container` in which these __names are stored and resolved to the mapped classes__ they refer towards.

In addition to the main class argument for `relationship()`, other arguments which depend upon the columns present on an as-yet undefined class may also be specified either as _Python functions_, or more commonly as _strings_. For most of these arguments except that of the main argument, __string inputs are evaluated as Python expressions__ using Python's built-in `eval()` function, as they are intended to receive complete SQL expressions.

> ##### Warning
>
> As the Python `eval()` function is used to __interpret the late-evaluated string arguments__ passed to `relationship()` _mapper configuration construct_, these arguments __should not be repurposed__ such that they would receive untrusted user input; `eval()` is __not secure against untrusted user input__.

The _full namespace_ available within this evaluation __includes all classes mapped for this `declarative base`__, as well as the _contents of the sqlalchemy package_, including expression functions like `desc()` and `sqlalchemy.sql.functions.func`.

For the case where _more than one module contains a class of the same name_, _string class names_ can also be specified as `module-qualified paths` within any of these string expressions.

```
class Parent(Base):
    __tablename__ = "parent_table"
    id = Column(Integer, primary_key=True)
    children = relationship(
        "Child", back_populates="parent",
        order_by="desc(module.Child.id)",
        primaryjoin="Parent.id == module.Child.parent_id",
    )
```

The `relationship()` construct also __accepts Python functions or lambdas__ as input for these arguments. This has the _advantage_ of providing __more compile-time safety__ and _better support for IDEs and PEP 484_ scenarios.

```
def _resolve_child_model():
    from myapplication import Child
    return Child


class Parent(Base):
    # ...
    children = relationship(
        _resolve_child_model(),
        order_by=lambda: desc(_resolve_child_model().idd),
        primaryjoin=lambda: Parent.id == _resolve_child_model().parent_id,
    )
```

It should also be noted that, _any MapperProperty construct_ __can be added to a declarative base mapping at any time__. If we wanted to implement this `relationship()` after the _Address_ class were available, we could also apply it afterwards.

```
class Parent(Base):
    ...


class Child(Base):
    ...


Parent.children = relationship(Child, primaryjoin=Child.parent_id == Parent.id)
```

> ##### Note
>
> _assignment of mapped properties_ to a _declaratively mapped class_ will __only function correctly__ if the `"declarative base"` class is used, which also provides for a _metaclass-driven_ `__setattr__()` method which will __intercept these operations__. It __will not work__ if the _declarative decorator_ provided by `registry.mapped()` is used, __nor will it work__ for an _imperatively mapped class_ mapped by `registry.map_imperatively()`.


##### Late-Evaluation for a many-to-many relationship

_Many-to-many relationships_ include a reference to an _additional_, typically __non-mapped Table object__ that is __typically present__ in the _MetaData collection_ referred towards by the _registry_. The _late-evaluation system_ also includes support for having this attribute be specified as a `string argument` which will be __resolved from this `MetaData` collection__. Below we specify an _association table_ `keyword_author`, sharing the _MetaData collection_ associated with our _declarative base_ and its _registry_. We can then refer to this _Table_ by name in the `relationship.secondary` parameter.
