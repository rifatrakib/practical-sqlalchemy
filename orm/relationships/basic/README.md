## Basic Relationship Patterns

A quick walkthrough of the basic relational patterns. The imports used for each of the following sections is as follows:

```
from sqlalchemy import Column, ForeignKey, Integer, Table
from sqlalchemy.orm import declarative_base, relationship

Base = declarative_base()
```


#### One To Many

A _one to many relationship_ places a `foreign key` on the _child table_ referencing the _parent_. `relationship()` is then __specified on the parent__, as referencing a _collection of items_ represented by the child.

To establish a __bidirectional relationship__ in _one-to-many_, where the `"reverse"` side is a _many to one_, specify an __additional `relationship()`__ and connect the two using the `relationship.back_populates` parameter.

_Alternatively_, the `relationship.backref` option may be __used on a single `relationship()`__ instead of using `relationship.back_populates`.


##### Configuring Delete Behavior for One to Many

It is often the case that _all Child objects_ should be __deleted__ when their _owning Parent is deleted_. To _configure_ this behavior, the `delete cascade option` described at _delete_ is used. An additional option is that a _Child_ object __can itself be deleted__ when it is _deassociated from its parent_. This behavior is described at `delete-orphan`.


#### Many To One

_Many to one_ places a `foreign key` in the __parent table referencing the child__. `relationship()` is __declared on the parent__, where a _new scalar-holding attribute_ will be created.

_Bidirectional behavior_ is achieved by adding a __second__ `relationship()` and applying the `relationship.back_populates` parameter in __both directions__.

_Alternatively_, the `relationship.backref` parameter may be __applied to a single `relationship()`__, such as `Parent.child`.


#### One To One

_One To One_ is essentially a `bidirectional relationship` with a __scalar attribute on both sides__. Within the ORM, _"one-to-one"_ is considered as a convention where the ORM expects that __only one related row will exist for any parent row__.

The _"one-to-one"_ convention is achieved by _applying a value_ of `False` to the `relationship.uselist` parameter of the `relationship()` construct, or in some cases the `backref()` construct, applying it on the _"one-to-many"_ or _"collection"_ side of a relationship.

In the example below we present a _bidirectional relationship_ that includes both `one-to-many (Parent.children)` and a `many-to-one (Child.parent)` relationships.

Above, `Parent.children` is the _"one-to-many"_ side __referring to a collection__, and `Child.parent` is the _"many-to-one"_ side __referring to a single object__. To convert this to _"one-to-one"_, the _"one-to-many"_ or _"collection"_ side is __converted into a scalar relationship__ using the `uselist=False` flag, renaming `Parent.children` to `Parent.child` for clarity.

Above, when we load a _Parent_ object, the _Parent.child_ attribute will __refer to a single Child object rather than a collection__. If we _replace_ the value of _Parent.child_ with a _new Child object_, the ORM's unit of work process will replace the previous Child row with the new one, setting the previous *child.parent_id* column to `NULL` __by default unless there are specific `cascade behaviors` set up__.

> ##### Note
>
> As mentioned previously, the ORM considers the _"one-to-one"_ pattern as a convention, where it _makes the assumption_ that when it loads the _Parent.child_ attribute on a _Parent_ object, it will __get only one row back__. If _more than one row_ is returned, the ORM will __emit a warning__.
>
> However, the _Child.parent_ side of the above relationship remains as a _"many-to-one"_ relationship and is __unchanged__, and there is __no intrinsic system__ within the ORM itself that _prevents more than one Child object to be created against the same Parent during persistence_. Instead, techniques such as `unique constraints` may be used in the actual database schema to _enforce_ this arrangement, where a _unique constraint_ on the *Child.parent_id* column would __ensure__ that _only one Child row may refer to a particular Parent row_ at a time.

In the case where the `relationship.backref` parameter is used to define the _"one-to-many"_ side, this can be converted to the _"one-to-one"_ convention using the `backref()` function which allows the relationship generated by the `relationship.backref` parameter to __receive custom parameters__, in this case the _uselist_ parameter.
