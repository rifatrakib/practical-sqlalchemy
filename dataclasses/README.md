## Integration with dataclasses and attrs

`SQLAlchemy 1.4` has __limited support__ for _ORM mappings_ that are _established against classes_ that have already been __pre-instrumented__ using either _Python's built-in_ `dataclasses` library or the `attrs` _third party integration library_.


> # Tip
> 
> `SQLAlchemy 2.0` will include a __new dataclass integration feature__ which allows for a particular class to be _mapped and converted into a Python dataclass simultaneously_, with _full support_ for `SQLAlchemy`'s _declarative syntax_. Within the scope of the 1.4 release, the `@dataclass` decorator is __used separately__ as documented in this section.


#### Applying ORM Mappings to an existing dataclass

The `dataclasses` module, added in `Python 3.7`, provides a `@dataclass` class decorator to __automatically generate__ _boilerplate definitions of common object methods_ including `__init__()`, `__repr__()`, and other methods. SQLAlchemy __supports the application of ORM mappings__ to a class _after it has been processed with the @dataclass decorator_, by using either the `registry.mapped()` class decorator, or the `registry.map_imperatively()` method to _apply ORM mappings_ to the class using `Imperative`.

To map an _existing dataclass_, SQLAlchemy's `"inline"` declarative directives __cannot be used directly__; ORM directives are assigned using one of three techniques:

* Using `"Declarative with Imperative Table"`, the _table/column to be mapped_ is defined using a `Table` object assigned to the `__table__` attribute of the class; `relationships` are defined within `__mapper_args__` dictionary. The _class is mapped_ using the `registry.mapped()` decorator. An example is below at `Mapping dataclasses using Declarative With Imperative Table`.

* Using full `"Declarative"`, the _Declarative-interpreted directives_ such as `Column`, `relationship()` are added to the `.metadata` dictionary of the `dataclasses.field()` construct, where they are __consumed by the declarative process__. The __class is again mapped__ using the `registry.mapped()` decorator. See the example below at `Mapping dataclasses using Declarative Mapping`.

* An `"Imperative"` mapping __can be applied to an existing dataclass__ using the `registry.map_imperatively()` method to _produce the mapping in exactly the same way_ as described at `Imperative Mapping`. This is illustrated below at `Mapping dataclasses using Imperative Mapping`.

The _general process_ by which SQLAlchemy _applies mappings to a dataclass_ is the __same as that of an ordinary class__, but _also includes_ that SQLAlchemy will __detect class-level attributes__ that were _part of the dataclasses declaration process_ and __replace them at runtime__ with the usual `SQLAlchemy ORM mapped attributes`. The `__init__` method that _would have been generated by dataclasses_ is __left intact__, as is the __same for all the other methods that dataclasses generates__ such as `__eq__()`, `__repr__()`, etc.


##### Mapping dataclasses using Declarative With Imperative Table

An example of a mapping using `@dataclass` using `Declarative with Imperative Table` (a.k.a. _Hybrid Declarative_) is below. A __complete `Table` object__ is __constructed explicitly__ and assigned to the `__table__` attribute. _Instance fields_ are defined using _normal dataclass syntaxes_. Additional `MapperProperty` definitions such as `relationship()`, are placed in the `__mapper_args__` class-level dictionary underneath the properties key, corresponding to the `mapper.properties` parameter.

In the above example, the `User.id`, `Address.id`, and `Address.user_id` attributes are defined as `field(init=False)`. This means that _parameters for these_ __won't be added to `__init__()` methods__, but `Session` will still be able to __set them after getting their values during flush__ from _autoincrement_ or _other default value generator_. To allow them to be _specified in the constructor explicitly_, they would instead be __given a default value of None__.

For a `relationship()` to be _declared separately_, it needs to be __specified directly__ within the `mapper.properties` dictionary which itself is specified within the `__mapper_args__` dictionary, so that it is passed to the `mapper()` construction function. An alternative to this approach is in the next example.


##### Mapping dataclasses using Declarative Mapping

The _fully declarative approach_ __requires__ that `Column` objects are _declared as class attributes_, which when using _dataclasses_ would __conflict with the dataclass-level attributes__. An approach to _combine these together_ is to __make use of the metadata attribute__ on the `dataclass.field` object, where _SQLAlchemy-specific mapping information may be supplied_. `Declarative` __supports extraction of these parameters__ when the class specifies the attribute `__sa_dataclass_metadata_key__`. This also provides a __more succinct method__ of _indicating the_ `relationship()` _association_.


##### Mapping dataclasses using Imperative Mapping

As described previously, a class which is set up as a _dataclass_ using the `@dataclass` decorator __can then be further decorated__ using the `registry.mapped()` decorator in order to __apply declarative-style mapping__ to the class. As an __alternative__ to using the `registry.mapped()` decorator, we may also _pass the class through_ the `registry.map_imperatively()` method instead, so that we may pass all `Table` and `mapper()` configuration imperatively to the function rather than having them defined on the class itself as class variables.


##### Using Declarative Mixins with Dataclasses

In the section `Composing Mapped Hierarchies with Mixins`, _Declarative Mixin_ classes are introduced. One _requirement of declarative mixins_ is that __certain constructs that can't be easily duplicated must be given as `callables`__, using the `declared_attr` decorator, such as in the example at `Mixing in Relationships`.

This form is supported within the _Dataclasses_ `field()` object by using a `lambda` to __indicate the SQLAlchemy construct inside the `field()`__. Using `declared_attr()` to _surround the lambda_ is __optional__. If we wanted to produce our `User` class above where the _ORM fields came from a mixin_ that is itself a `dataclass`, the form would be as follows.


#### Applying ORM mappings to an existing attrs class

The `attrs` library is a _popular third party library_ that __provides similar features__ as `dataclasses`, with _many additional features_ provided __not found__ in ordinary `dataclasses`.

A class augmented with `attrs` uses the `@define` decorator. This decorator initiates a process to __scan the class for attributes that define the class' behavior__, which are then used to __generate methods, documentation, and annotations__.

The _SQLAlchemy ORM_ supports _mapping_ an `attrs` class using `Declarative with Imperative Table` or `Imperative mapping`. The _general form_ of these two styles is __fully equivalent__ to the `Mapping dataclasses using Declarative Mapping` and `Mapping dataclasses using Declarative With Imperative Table` mapping forms used with `dataclasses`, where the _inline attribute directives_ used by `dataclasses` or `attrs` are __unchanged__, and _SQLAlchemy_'s `table-oriented instrumentation` is __applied at runtime__.

The `@define` decorator of `attrs` _by default_ __replaces the annotated class__ with a _new_ `__slots__` _based class_, which is __not supported__. When using the _old style annotation_ `@attr.s` or using `define(slots=False)`, the class __does not get replaced__. Furthermore `attrs` __removes its own class-bound attributes after the decorator runs__, so that _SQLAlchemy's mapping process_ __takes over__ these attributes without any issue. _Both decorators_, `@attr.s` and `@define(slots=False)` __work with `SQLAlchemy`__.


##### Mapping attrs with Declarative "Imperative Table"

In the `"Declarative with Imperative Table"` style, a `Table` object is __declared inline__ with the _declarative class_. The `@define` decorator is __applied to the class first__, then the `registry.mapped()` decorator __second__.

> ##### Note
> 
> The `attrs` `slots=True` option, which enables `__slots__` on a _mapped class_, __cannot be used__ with _SQLAlchemy mappings_ __without fully implementing alternative attribute instrumentation__, as _mapped classes_ __normally rely upon direct access to__ `__dict__` for _state storage_. Behavior is _undefined_ when _this option_ is __present__.
