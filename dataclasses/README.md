## Integration with dataclasses and attrs

`SQLAlchemy 1.4` has __limited support__ for _ORM mappings_ that are _established against classes_ that have already been __pre-instrumented__ using either _Python's built-in_ `dataclasses` library or the `attrs` _third party integration library_.


> # Tip
> 
> `SQLAlchemy 2.0` will include a __new dataclass integration feature__ which allows for a particular class to be _mapped and converted into a Python dataclass simultaneously_, with _full support_ for `SQLAlchemy`'s _declarative syntax_. Within the scope of the 1.4 release, the `@dataclass` decorator is __used separately__ as documented in this section.


#### Applying ORM Mappings to an existing dataclass

The `dataclasses` module, added in `Python 3.7`, provides a `@dataclass` class decorator to __automatically generate__ _boilerplate definitions of common object methods_ including `__init__()`, `__repr__()`, and other methods. SQLAlchemy __supports the application of ORM mappings__ to a class _after it has been processed with the @dataclass decorator_, by using either the `registry.mapped()` class decorator, or the `registry.map_imperatively()` method to _apply ORM mappings_ to the class using `Imperative`.

To map an _existing dataclass_, SQLAlchemy's `"inline"` declarative directives __cannot be used directly__; ORM directives are assigned using one of three techniques:

* Using `"Declarative with Imperative Table"`, the _table/column to be mapped_ is defined using a `Table` object assigned to the `__table__` attribute of the class; `relationships` are defined within `__mapper_args__` dictionary. The _class is mapped_ using the `registry.mapped()` decorator. An example is below at `Mapping dataclasses using Declarative With Imperative Table`.

* Using full `"Declarative"`, the _Declarative-interpreted directives_ such as `Column`, `relationship()` are added to the `.metadata` dictionary of the `dataclasses.field()` construct, where they are __consumed by the declarative process__. The __class is again mapped__ using the `registry.mapped()` decorator. See the example below at `Mapping dataclasses using Declarative Mapping`.

* An `"Imperative"` mapping __can be applied to an existing dataclass__ using the `registry.map_imperatively()` method to _produce the mapping in exactly the same way_ as described at `Imperative Mapping`. This is illustrated below at `Mapping dataclasses using Imperative Mapping`.

The _general process_ by which SQLAlchemy _applies mappings to a dataclass_ is the __same as that of an ordinary class__, but _also includes_ that SQLAlchemy will __detect class-level attributes__ that were _part of the dataclasses declaration process_ and __replace them at runtime__ with the usual `SQLAlchemy ORM mapped attributes`. The `__init__` method that _would have been generated by dataclasses_ is __left intact__, as is the __same for all the other methods that dataclasses generates__ such as `__eq__()`, `__repr__()`, etc.


##### Mapping dataclasses using Declarative With Imperative Table

An example of a mapping using `@dataclass` using `Declarative with Imperative Table` (a.k.a. _Hybrid Declarative_) is below. A __complete `Table` object__ is __constructed explicitly__ and assigned to the `__table__` attribute. _Instance fields_ are defined using _normal dataclass syntaxes_. Additional `MapperProperty` definitions such as `relationship()`, are placed in the `__mapper_args__` class-level dictionary underneath the properties key, corresponding to the `mapper.properties` parameter.

In the above example, the `User.id`, `Address.id`, and `Address.user_id` attributes are defined as `field(init=False)`. This means that _parameters for these_ __won't be added to `__init__()` methods__, but `Session` will still be able to __set them after getting their values during flush__ from _autoincrement_ or _other default value generator_. To allow them to be _specified in the constructor explicitly_, they would instead be __given a default value of None__.

For a `relationship()` to be _declared separately_, it needs to be __specified directly__ within the `mapper.properties` dictionary which itself is specified within the `__mapper_args__` dictionary, so that it is passed to the `mapper()` construction function. An alternative to this approach is in the next example.


##### Mapping dataclasses using Declarative Mapping

The _fully declarative approach_ __requires__ that `Column` objects are _declared as class attributes_, which when using _dataclasses_ would __conflict with the dataclass-level attributes__. An approach to _combine these together_ is to __make use of the metadata attribute__ on the `dataclass.field` object, where _SQLAlchemy-specific mapping information may be supplied_. `Declarative` __supports extraction of these parameters__ when the class specifies the attribute `__sa_dataclass_metadata_key__`. This also provides a __more succinct method__ of _indicating the_ `relationship()` _association_.


##### Mapping dataclasses using Imperative Mapping

As described previously, a class which is set up as a _dataclass_ using the `@dataclass` decorator __can then be further decorated__ using the `registry.mapped()` decorator in order to __apply declarative-style mapping__ to the class. As an __alternative__ to using the `registry.mapped()` decorator, we may also _pass the class through_ the `registry.map_imperatively()` method instead, so that we may pass all `Table` and `mapper()` configuration imperatively to the function rather than having them defined on the class itself as class variables.
